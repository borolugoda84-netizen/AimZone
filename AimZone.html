<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modern Shooter — Single File Game</title>
<style>
  :root{
    --bg:#0d1720;
    --card: rgba(255,255,255,0.03);
    --glass-border: rgba(255,255,255,0.06);
    --accent1:#00d4ff;
    --accent2:#7a00ff;
    --danger:#ff5e6c;
    --text:#e6eef8;
    --muted: rgba(230,238,248,0.65);
    --radius:14px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    min-height:100vh;
    font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    background: radial-gradient(900px 400px at 10% 20%, rgba(122,0,255,0.04), transparent 8%),
                linear-gradient(180deg,var(--bg) 0%, #071022 100%);
    color:var(--text);
    display:flex;align-items:center;justify-content:center;padding:28px;
  }

  .wrap{
    width:980px; max-width:calc(100% - 56px); display:flex; gap:24px; align-items:flex-start;
  }

  /* left: game card */
  .gameCard{
    width:640px; min-height:520px; padding:16px; border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.03));
    border:1px solid var(--glass-border); box-shadow: 0 8px 30px rgba(2,6,23,0.65);
    position:relative;
  }

  .hud{display:flex; gap:12px; align-items:center; margin-bottom:12px;}
  .panel{background:var(--card); padding:10px 12px; border-radius:10px; min-width:88px; text-align:center; border:1px solid rgba(255,255,255,0.03)}
  .panel small{display:block; font-size:11px; color:var(--muted); font-weight:600}
  .panel .val{font-weight:800; font-size:18px; margin-top:4px}

  .gameArea{
    width:100%; height:420px; border-radius:10px; overflow:hidden; position:relative;
    background: linear-gradient(180deg,#0e1720 0%, #0b1116 100%); display:flex; align-items:center; justify-content:center;
  }

  canvas{display:block; background:linear-gradient(180deg,#0c1117 0%, #061018 100%); width:360px; height:420px; border-radius:8px; box-shadow: 0 10px 30px rgba(0,0,0,0.7);}

  .overlay{position:absolute; inset:16px; display:flex; align-items:center; justify-content:center; z-index:40}
  .startCard{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); padding:14px 18px; border-radius:12px; border:1px solid rgba(255,255,255,0.04); text-align:center; backdrop-filter: blur(6px)}
  .startCard h2{font-size:18px; margin-bottom:6px}
  .muted{color:var(--muted); font-size:13px}

  /* right: control panel */
  .sidePanel{
    width:300px; min-height:520px; padding:18px; border-radius:var(--radius);
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid var(--glass-border); box-shadow: 0 8px 30px rgba(2,6,23,0.55);
  }
  .title{font-size:20px; font-weight:700; margin-bottom:8px}
  .subtitle{font-size:13px; color:var(--muted); margin-bottom:16px}

  .controls{display:flex; gap:8px; margin-bottom:12px}
  .btn{flex:1; padding:10px 12px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); cursor:pointer; font-weight:800}
  .btn.primary{background: linear-gradient(90deg,var(--accent1),var(--accent2)); color:#06111a; box-shadow: 0 8px 22px rgba(122,0,255,0.12)}
  .btn.warn{background: linear-gradient(90deg,#ff9a9a,#ff5e6c); color:white}
  .gauge{margin-top:10px; padding:12px; border-radius:10px; background:rgba(255,255,255,0.01); border:1px solid rgba(255,255,255,0.02)}
  .bar{height:10px; background:rgba(255,255,255,0.04); border-radius:8px; overflow:hidden}
  .bar > i{display:block;height:100%; width:0%; background: linear-gradient(90deg,var(--accent1),var(--accent2)); transition:width 120ms linear}

  .meta{display:flex; justify-content:space-between; margin-top:8px; color:var(--muted); font-size:13px}

  .touchControls{display:flex; gap:10px; justify-content:center; margin-top:14px}
  .joy{width:56px; height:56px; border-radius:10px; background:var(--card); display:flex; align-items:center; justify-content:center; font-weight:800; border:1px solid rgba(255,255,255,0.03); cursor:pointer; user-select:none}

  .tips{font-size:13px; color:var(--muted); margin-top:14px}
  .tips ul{margin-left:18px; margin-top:8px; line-height:1.45}

  @media (max-width:1000px){
    .wrap{flex-direction:column; align-items:center}
    .gameCard, .sidePanel{width:100%}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="gameCard">
      <div class="hud">
        <div class="panel"><small>Score</small><div id="score" class="val">0</div></div>
        <div class="panel"><small>High</small><div id="high" class="val">0</div></div>
        <div class="panel"><small>Wave</small><div id="wave" class="val">0</div></div>
        <div style="flex:1"></div>
        <div class="panel" style="min-width:140px"><small>Controls</small><div class="muted">← → • Space • Tap</div></div>
      </div>

      <div class="gameArea">
        <canvas id="gameCanvas" width="360" height="420"></canvas>

        <div class="overlay" id="overlay">
          <div class="startCard" id="startCard">
            <h2>Modern Shooter</h2>
            <div class="muted">Move your ship and shoot enemies. Survive waves to earn points.</div>
            <div style="height:10px"></div>
            <div style="display:flex; gap:8px; justify-content:center">
              <button class="btn primary" id="btnStart">Start</button>
              <button class="btn" id="btnHow">How</button>
            </div>
            <div style="height:8px"></div>
            <div class="muted">Use <strong>← →</strong> to move and <strong>Space</strong> to shoot</div>
          </div>
        </div>

      </div>
    </div>

    <aside class="sidePanel">
      <div class="title">Modern UI Controls</div>
      <div class="subtitle">HUD, speed gauge, and touch-friendly controls</div>

      <div class="controls">
        <div id="startBtn" class="btn primary">Start</div>
        <div id="pauseBtn" class="btn">Pause</div>
        <div id="resetBtn" class="btn warn">Reset</div>
      </div>

      <div class="gauge">
        <div style="display:flex; justify-content:space-between">
          <div style="font-weight:700">Difficulty</div><div id="difficulty" style="font-weight:700">1.0</div>
        </div>
        <div style="height:8px"></div>
        <div class="bar"><i id="diffBar"></i></div>
        <div class="meta"><div>Enemies</div><div id="enemyCount">0</div></div>
      </div>

      <div style="height:10px"></div>

      <div style="font-weight:700; margin-bottom:8px">Touch Controls</div>
      <div class="touchControls">
        <div id="leftBtn" class="joy">◀</div>
        <div id="shootBtn" class="joy">●</div>
        <div id="rightBtn" class="joy">▶</div>
      </div>

      <div class="tips">
        Tips:
        <ul>
          <li>Tap shoot rapidly to clear enemies.</li>
          <li>Waves get harder over time — keep moving.</li>
          <li>High score is saved locally in your browser.</li>
        </ul>
      </div>
    </aside>
  </div>

<script>
/* Modern Shooter
   Single-file canvas shooter with modern UI.
   Controls: ArrowLeft, ArrowRight, Space (or touch)
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const waveEl = document.getElementById('wave');
const diffEl = document.getElementById('difficulty');
const diffBar = document.getElementById('diffBar');
const enemyCountEl = document.getElementById('enemyCount');

const overlay = document.getElementById('overlay');
const btnStart = document.getElementById('btnStart');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const btnHow = document.getElementById('btnHow');

const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const shootBtn = document.getElementById('shootBtn');

let state = {
  playing: false,
  paused: false,
  score: 0,
  high: Number(localStorage.getItem('shooter_high') || 0),
  wave: 0,
  difficulty: 1.0,
  keys: {left:false, right:false, shoot:false},
  player: { x: canvas.width/2, y: canvas.height - 48, w: 44, h: 28, speed: 240 },
  bullets: [],
  enemies: [],
  lastShot: 0,
  shotCooldown: 200, // ms
  lastFrame: 0,
  spawnTimer: 0,
  spawnInterval: 1200,
};

highEl.textContent = state.high;
updateHUD();

function updateHUD(){
  scoreEl.textContent = Math.floor(state.score);
  highEl.textContent = Math.floor(state.high);
  waveEl.textContent = state.wave;
  diffEl.textContent = state.difficulty.toFixed(1);
  diffBar.style.width = Math.min(100,(state.difficulty/6)*100) + '%';
  enemyCountEl.textContent = state.enemies.length;
}

/* Utility */
function rand(min,max){ return Math.floor(Math.random() * (max-min+1)) + min; }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

/* Game entity creation */
function spawnEnemyRow(count=4){
  const padding = 12;
  const totalW = canvas.width - padding*2;
  const spacing = totalW / count;
  for(let i=0;i<count;i++){
    const w = rand(24,42);
    const h = rand(20,36);
    const x = padding + i*spacing + rand(0, Math.max(0, spacing - w));
    const y = -rand(20, 120) - (i*40);
    state.enemies.push({
      x, y, w, h,
      speed: 40 + state.difficulty * 30 + rand(0,40),
      hp: 1 + Math.floor(state.difficulty/2),
      colorHue: rand(30,50) // yellow/orange hues for visibility
    });
  }
}

/* Shoot bullet */
function shootBullet(){
  const now = performance.now();
  if(now - state.lastShot < state.shotCooldown) return;
  state.lastShot = now;
  const b = {
    x: state.player.x,
    y: state.player.y - 14,
    w: 6, h: 12,
    speed: 480 + (state.difficulty * 80)
  };
  state.bullets.push(b);
}

/* Collision AABB */
function collide(a,b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* Reset / Start / End */
function resetGame(){
  state.playing = false;
  state.paused = false;
  overlay.style.display = 'flex';
  const startCard = document.getElementById('startCard');
  startCard.querySelector('h2').textContent = 'Modern Shooter';
  // clear arrays
  state.bullets = [];
  state.enemies.forEach(e=>{}); state.enemies=[];
  state.score = 0;
  state.wave = 0;
  state.difficulty = 1.0;
  updateHUD();
}

function startGame(){
  overlay.style.display = 'none';
  state.playing = true;
  state.paused = false;
  state.bullets = [];
  state.enemies = [];
  state.score = 0;
  state.wave = 0;
  state.difficulty = 1.0;
  state.spawnTimer = 0;
  state.lastFrame = performance.now();
  state.player.x = canvas.width/2 - state.player.w/2;
  spawnEnemyRow(3); // initial
  state.wave = 1;
  updateHUD();
  requestAnimationFrame(gameLoop);
}

function pauseGame(){
  if(!state.playing) return;
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
  if(!state.paused){
    state.lastFrame = performance.now();
    requestAnimationFrame(gameLoop);
  }
}

function endGame(){
  state.playing = false;
  state.paused = false;
  overlay.style.display = 'flex';
  const startCard = document.getElementById('startCard');
  startCard.querySelector('h2').textContent = 'Game Over';
  // show score message
  let msg = startCard.querySelector('.scoreMsg');
  if(msg) msg.remove();
  msg = document.createElement('div');
  msg.className = 'scoreMsg muted';
  msg.style.marginTop = '8px';
  msg.innerHTML = `Score: <strong style="color:var(--accent1)">${Math.floor(state.score)}</strong>`;
  startCard.appendChild(msg);
  // update high
  if(state.score > state.high){
    state.high = Math.floor(state.score);
    localStorage.setItem('shooter_high', String(state.high));
  }
  updateHUD();
}

/* Game loop */
function gameLoop(ts){
  if(!state.playing || state.paused) return;
  const dt = (ts - state.lastFrame) / 1000; // seconds
  state.lastFrame = ts;

  // difficulty ramps slowly
  state.difficulty += dt * 0.08; // slow ramp
  state.difficulty = clamp(state.difficulty, 1.0, 6.0);

  // spawn logic: spawn new wave when enough time or few enemies remain
  state.spawnTimer += dt * 1000;
  const spawnThreshold = Math.max(500, 1200 - state.difficulty * 120);
  if(state.spawnTimer > spawnThreshold && state.enemies.length < 6 + Math.floor(state.difficulty)){
    // spawn a row or single enemies depending on difficulty
    const count = clamp(2 + Math.floor(state.difficulty/1.5), 2, 6);
    spawnEnemyRow(count);
    state.spawnTimer = 0;
    state.wave += 0.15; // slightly increase wave count
  }

  // player movement
  const move = state.player.speed * dt;
  if(state.keys.left) state.player.x -= move;
  if(state.keys.right) state.player.x += move;
  state.player.x = clamp(state.player.x, 8, canvas.width - state.player.w - 8);

  // auto-shoot if holding shoot
  if(state.keys.shoot) shootBullet();

  // bullets update
  for(let i = state.bullets.length - 1; i >= 0; i--){
    const b = state.bullets[i];
    b.y -= b.speed * dt;
    if(b.y + b.h < 0){ state.bullets.splice(i,1); continue; }
  }

  // enemies update
  for(let i = state.enemies.length - 1; i >= 0; i--){
    const e = state.enemies[i];
    e.y += e.speed * dt;
    // check collision with player (enemy reaches player)
    const playerBox = {x: state.player.x, y: state.player.y - state.player.h/2, w: state.player.w, h: state.player.h};
    const enemyBox = {x: e.x, y: e.y, w: e.w, h: e.h};
    if(collide(playerBox, enemyBox)){
      endGame(); return;
    }
    // bullets vs enemy
    for(let j = state.bullets.length - 1; j >= 0; j--){
      const b = state.bullets[j];
      if(collide({x:b.x, y:b.y, w:b.w, h:b.h}, enemyBox)){
        // hit
        state.bullets.splice(j,1);
        e.hp -= 1;
        if(e.hp <= 0){
          // destroy enemy
          state.enemies.splice(i,1);
          state.score += 10 + Math.floor(5 * state.difficulty);
          break;
        }
      }
    }
    // if enemy moved off bottom, remove and penalize a small amount
    if(e.y > canvas.height + 40){
      state.enemies.splice(i,1);
      state.score = Math.max(0, state.score - Math.floor(5 * state.difficulty));
    }
  }

  // subtle score increase over time (survival)
  state.score += dt * state.difficulty * 2;

  updateHUD();
  render();

  requestAnimationFrame(gameLoop);
}

/* Render everything */
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background stars / subtle grid
  drawBackground();

  // draw player
  drawPlayer();

  // draw bullets
  for(const b of state.bullets) drawBullet(b);

  // draw enemies
  for(const e of state.enemies) drawEnemy(e);

  // top overlay text (optional)
  // draw simple HUD in canvas center (not necessary)
}

function drawBackground(){
  // subtle moving gradient / stars
  // draw slightly-scrolling starfield using time-based offset
  const t = performance.now() / 6000;
  ctx.save();
  const grd = ctx.createLinearGradient(0,0,0,canvas.height);
  grd.addColorStop(0,'rgba(10,16,22,0.9)');
  grd.addColorStop(1,'rgba(2,6,10,0.95)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // faint vertical grid lines for depth
  ctx.globalAlpha = 0.035;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  for(let x=0; x<=canvas.width; x += 60){
    ctx.beginPath();
    ctx.moveTo(x + (Math.sin(t + x)*2), 0);
    ctx.lineTo(x + (Math.sin(t + x)*2), canvas.height);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawPlayer(){
  const p = state.player;
  // draw shadow
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath();
  ctx.ellipse(p.x + p.w/2, p.y + p.h + 6, p.w*0.6, 6, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // draw ship body
  ctx.save();
  const grd = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
  grd.addColorStop(0, '#00f0ff'); grd.addColorStop(1, '#0070ff');
  ctx.fillStyle = grd;
  roundRect(ctx, p.x, p.y - p.h/2, p.w, p.h, 8, true, false);

  // cockpit
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  roundRect(ctx, p.x + p.w*0.18, p.y - p.h/2 + 6, p.w*0.64, p.h*0.34, 5, true, false);

  // gun muzzle glow
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(p.x + p.w/2 - 6, p.y - p.h/2 - 8, 12, 6);

  ctx.restore();
}

function drawBullet(b){
  ctx.save();
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(b.x + b.w/2 - 1, b.y, b.w, b.h);
  ctx.restore();
}

function drawEnemy(e){
  ctx.save();
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.beginPath();
  ctx.ellipse(e.x + e.w/2, e.y + e.h + 6, e.w*0.6, 6, 0, 0, Math.PI*2);
  ctx.fill();

  // body
  const color = `hsl(${e.colorHue}, 90%, 60%)`;
  const grad = ctx.createLinearGradient(e.x, e.y, e.x, e.y + e.h);
  grad.addColorStop(0, color);
  grad.addColorStop(1, `hsl(${e.colorHue - 10}, 80%, 45%)`);
  ctx.fillStyle = grad;
  roundRect(ctx, e.x, e.y, e.w, e.h, 6, true, false);

  // HP indicator (tiny)
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(e.x, e.y - 6, e.w, 4);
  const hpPct = clamp(e.hp / (1 + Math.floor(state.difficulty/2)), 0, 1);
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.fillRect(e.x + 2, e.y - 5, (e.w - 4) * hpPct, 2);

  ctx.restore();
}

/* helper to draw rounded rect */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof r === 'undefined') r = 5;
  if (typeof r === 'number') r = {tl: r, tr: r, br: r, bl: r};
  ctx.beginPath();
  ctx.moveTo(x + r.tl, y);
  ctx.lineTo(x + w - r.tr, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
  ctx.lineTo(x + w, y + h - r.br);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
  ctx.lineTo(x + r.bl, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
  ctx.lineTo(x, y + r.tl);
  ctx.quadraticCurveTo(x, y, x + r.tl, y);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* Input handlers */
document.addEventListener('keydown', (e)=>{
  if(e.code === 'ArrowLeft'){ e.preventDefault(); state.keys.left = true; }
  if(e.code === 'ArrowRight'){ e.preventDefault(); state.keys.right = true; }
  if(e.code === 'Space'){ e.preventDefault(); state.keys.shoot = true; shootBullet(); }
  // P to pause
  if(e.code === 'KeyP'){ pauseGame(); }
});
document.addEventListener('keyup', (e)=>{
  if(e.code === 'ArrowLeft'){ state.keys.left = false; }
  if(e.code === 'ArrowRight'){ state.keys.right = false; }
  if(e.code === 'Space'){ state.keys.shoot = false; }
});

/* touch controls: hold left/right, tap shoot */
leftBtn.addEventListener('touchstart', e=>{ e.preventDefault(); state.keys.left = true; });
leftBtn.addEventListener('touchend', e=>{ e.preventDefault(); state.keys.left = false; });
rightBtn.addEventListener('touchstart', e=>{ e.preventDefault(); state.keys.right = true; });
rightBtn.addEventListener('touchend', e=>{ e.preventDefault(); state.keys.right = false; });
shootBtn.addEventListener('touchstart', e=>{ e.preventDefault(); shootBullet(); });

leftBtn.addEventListener('mousedown', e=>{ state.keys.left = true; });
leftBtn.addEventListener('mouseup', e=>{ state.keys.left = false; });
rightBtn.addEventListener('mousedown', e=>{ state.keys.right = true; });
rightBtn.addEventListener('mouseup', e=>{ state.keys.right = false; });
shootBtn.addEventListener('mousedown', e=>{ shootBullet(); });

/* UI Hookups */
btnStart.addEventListener('click', startGame);
startBtn.addEventListener('click', startGame);
pauseBtn.addEventListener('click', pauseGame);
resetBtn.addEventListener('click', resetGame);
btnHow.addEventListener('click', ()=>{ alert('Move with left/right arrows. Press Space to shoot. Tap controls available on mobile.'); });

/* initial placement */
state.player.x = canvas.width/2 - state.player.w/2;

/* initial render loop when idle: show subtle animation */
let idleAnim = 0;
function idleLoop(ts){
  if(state.playing && !state.paused) return;
  idleAnim += 0.01;
  // gentle starfield movement
  render();
  requestAnimationFrame(idleLoop);
}
requestAnimationFrame(idleLoop);

/* keep HUD updated periodically */
setInterval(()=> {
  updateHUD();
}, 150);

/* Ensure canvas adjusts visually on resize (we keep internal resolution fixed for crispness) */
window.addEventListener('resize', ()=>{/* no-op for now */});

/* Start by rendering once */
render();
updateHUD();
</script>
</body>
</html>
